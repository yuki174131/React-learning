- ルーティングについて
    - SPA におけるルーティングとは
        - 典型的な SPA では、 サーバへの初回のリクエストに対してその URL にかかわらず、アプリケーション全体が記述された JavaScript のコードのかたまりとアセットファイルが返される
        - それ以降のアプリケーション内部でのページ遷移は、アプリケーションが動的に DOM 要素を書き換えることで移動してるように見えるだけ
        - それによってブラウザのアドレスバーの URL が書き換わることがあっても、その処理もブラウザの中で完結していて実際にサーバへリクエストが飛ぶことは原則的にない
        - SPA とサーバサイドアプリケーションのルーティングのちがい。
            - サーバへリクエストが飛ばない
                - Google Analytics などを使ったアクセス解析を行う上でネック 
                - ソリューションとしては、ルーティン グが実行されてURLが書き換わる際Effect HookでGoogle Analyticsにリクエストを発行する処理を差 し込むといった方法がある
                    - https://github.com/react-ga/react-ga/wiki/React-Router-v4-withTracker
            - サーバが HTTP ステータスコードを返せないことも注意
                - 既存のページを削除した ときにサーバが 404 を返すようにすれば、検索エンジンがそれを検知してインデックスから削除してくれ るけど、SPA だとそうはいかない
                - サイトマップや Google Analytics の管理機能を使うことでフォローする必要がある
            - ルーティングの適用単位がコンポーネントだというのも前提知識として知っておく必要がある
                - React の場合はルートのコンポーネントから階層を下りていってこ こから先はこのパスのときにはこのコンポーネントをマウントする
    - ルーティングライブラリの選定
        - React 向けのルーティングライブラリについては、現状 React Router がデファクトスタンダードと言っていい
    - ファイルシステムベースのルーティング
        - React をベースにしたフレームワークがいくつも出ていて、それらは Web アプリケーションを 開発するにあたって React 単体では機能が足りなかったり設定が面倒だったりするものを最初から補ってくれてる。もっともメジャーなのは Next.js
            - サーバサイドレンダリングや画像の最適化、コンテン ツの国際化などが手軽にできるようになってる
            - ルーティングの機能も用意されているんだけど、 ファイルを置いた構造がそのままアプリケーションのパスになるという直感的なもので、これが広く受け入れられてる
            - pages/ というディレクトリをルートとして、そこに置いたファイルやディレクトリの 名前がパスに反映される
- React Router の基本的な使い方
    - React Router を導入
        - yarn add react-router-dom
        - React Router を導入するには通常、ルーティング機能を提供するプロバイダコンポーネントをトップレ ベルで設定する。手っ取り早いのは src/main.tsx へ次のように記述すること。これで React Router の各 種 API がコンポーネントツリーの下の階層で使えるようになる
            - import React from 'react';
            import ReactDOM from 'react-dom/client';
            import { BrowserRouter } from 'react-router-dom'; import App from './App';

            ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render( 
                <BrowserRouter>
                    <App />
                </BrowserRouter>, 
                document.getElementById('root'),
            );
        - react-router-dom が提供するルーティングプロバイダ・コンポーネントには次の 4 つがあって、 これらは共通して react-router が提供してるより低レベルの Router コンポーネントを下敷きにしている。通常はユースケースに合わせてこれらを使い分けるようになってる
            - <BrowserRouter>
                - History API を使って UI と URL を動的に同期してくれるコンポーネント。公式の推奨インターフェース
                - 一般的なブラウザ向けの開発ではこれ一択といっていい
            - <HashRouter>
                - URL に # がつくルーティング機能を提供するもの
                - これは今さら使う機会はほぼないし、公式も使わないようにと強く言ってる
            - <MemoryRouter>
                - ブラウザのアドレスバーの URL が一切替わらなくてメモリの中だけで履歴が管理される
                - React Native と組み合わせてテストの際に用いられたりする
            - <NativeRouter>
                -  React Native 用のインターフェース
            - <StaticRouter>
                - サーバサイドレンダリングを導入する際に Node.js 環境で使われるコンポーネント
            - これらのプロバイダコンポーネントが具体的に何をやってくれるかというと、下位層の子孫コンポーネ ントの中で <Link> や <Navigate> といった機能タグが使えるようにしてくれたり、 match や location、history といったオブジェクトへアクセスできるようにしてくれたりしてる
    - React Router のコンポーネント API
        - JSX の中に要素タグとして組み込むタイプのもの
            - 12-routing/03-react-router/src/routes/index.tsxを参照
            - URL のパスが path の値にマッチすると element に渡されたコンポーネントがレンダリングされる
            - <Routes> の中で <Route> は入れ子にできて、すべてのパスは相対的になる
            - パスの記述で気をつけたほうがいい点
                - 末尾に / をつけても無視される
                - 一般的な glob や正規表現は使えない
                - ワイルドカード * のみ使用可だが、記述できるのは末尾のみ 
                - 大文字・小文字を区別したい場合は Route コンポーネントに caseSensitive 属性を指定する
            - <Route path="*" element={<Navigate to="/" replace />} />
                - レンダリングされると to 属性で示したパスに現在の location が変更される。なお replace 属性が有効になってると、変更前の location の履歴が history に残らない
                - このケースでたとえばユーザーが /nowhere というパスにアクセスしたとする。すると最後までどの設 定パスにもマッチせずトップにリダイレクトされるわけだけど、replace 属性が有効になっていると /nowhere にアクセスした歴史が残らない
            - Link コンポーネント の使い方
                - <a> タグを使って書くと、そのリンクを踏んだ時点で React Router の管轄外となって、管理していた履 歴がすべて消えてしまうよ。普通に Web サーバにリクエストが飛んで、SPA のコード全体がリロードされることになる
                - アプリケーション内リンクは必 ず <Link> を使って書くように
                - リンク先を設定する属性の to には 2 種類の値が渡せる。まずパスの文字列ね。これは絶対パスでも相対パスでも、どちらの形式でも可
                - もうひとつは history パッケージで定義されてる Path インターフェースの各要素をオプション化したオブジェクト。こっちならパス 名の他にクエリパラメータやハッシュも設定できる
                - <Link> はユーザーに見せたくない情報を state 属性に埋め込んで、リンク先に受け渡すこともで きる。Boolean 型の属性である replace を指定すれば、クリックした時点でそこにいた location の履歴が history から消せる
                - NavLink コンポーネントというのもある。これはいま現在、そのパスにマッチ する場所にいるかどうかを属性に渡せる特殊なバージョンの <Link>
                - style と className の属性にコールバックを渡すようになってるんですね。その引数のプロパティ isActive がパスにマッチしてるときは true になってる
            - コンポーネント API として最後に紹介するのが <Outlet>。これは子ルート要素のコンポーネントをレ ンダリングするために用意しておくプレースホルダー的なコンポーネント
     - React Router の Hooks API
        - React Router が提供する Hooks インターフェースの よく使われる API
            - useLocation 
                - history パッケージで定義されてる location オブジェクトをコンポーネント の中で取得するための API 
                - 今いるページのパスとクエリパラメータ、ハッシュ、それに遷移前に設定されていた state 値
                - location オブジェクトごとに生成されるユニークな文字列
            - useSearchParams 
                - そのページのクエリパラメータで作成された URLSearchParams オブジェクトが返ってくる
            - useNavigate 
                - navigate 関数を返す API で、役割は <Navigate> コンポーネントとほぼ同 じ
            - useParams 
            - useMatch
    - React Router をアプリケーションで使う
        - 12-routing/03-react-routerを参照
    - Redux 公式スタイルガイド
        - https://redux.js.org/style-guide/
        - Redux を用いたアプリケーションのコードを書くにあたって公式が推奨する設計パターンや開発のベストプラクティス、アプローチの提案といったものの寄せ集め
        - 優先度 A: 必須
            -  Stateを直接書き換えない
            -  Reducerに副作用を持たせない
            - シリアライズできない値を State や Action に入れない
            - Storeはひとつのアプリにつきひとつだけ
- Redux Toolkit を使って楽をしよう
    - Reduxは必要とされる定型構文が多くて、コードの記述量がやたらと増える
    - そうしてリリースされたのが Redux Toolkit、略して RTK
    - RTK が提供している主要な API は次の 4 つ
        - configureStore ...... 各種デフォルト値が設定可能な createStore のカスタム版 
        - createReducer ...... reducer の作成を簡単にしてくれる
        - createAction ...... action creator を作成する
        - createSlice ...... action の定義と action creator 、 reducer をまとめて生成できる
    - 03-rtk/src/stores/counter/actions.tsを参照
    - 03-rtk/src/stores/counter/reducers.tsを参照
    - 03-rtk/src/stores/counter/counters.tsを参照
    - 03-rtk/src/stores/counter/index.tsxを参照
    - Redux DevTools 拡張をインストール
        - 『Element』『Console』とかが並んでるタブに 『Redux』がある。それをアクティブ
        - カウンターのボタンを押していくと、左に発行さ れた action の履歴が追加されていく
- useReducer はローカルに使える Redux
    - useReducer で Redux の処理を書き直す
    - useReducer の使い方
        - const [state, dispatch] = useReducer(reducer, initialState);
        - 04-use-reducer/src/components/ecosystems/BeadsCounter.tsxを参照
-  useReducer と State Hook の正体
    - コンポーネントの機能が複雑化してくると state の数が増え、ある state の更新ロジックが別の state を 参照するようになる。2 つくらいならともかく、たくさんの state が更新時に相互参照し、さらにそれが useEffect の副作用処理の中で行われたりすると人間の頭では追いつかなくなって、予期せぬ更新が予期 せぬ場所で起きるカオスな状態に陥りがちになる
    - useReducer を使えばコンポーネントの state を Redux のようにシング ルツリーのオブジェクトに格納して、その中身を reducer によって副作用を排除しつつ更新できるように なる
    - useState って実体はひとつの setter action だけを持つ useReducer なのよ。だったら複数の state がある場合は、最初から useReducer を使えばいいじゃないって話になる
    
