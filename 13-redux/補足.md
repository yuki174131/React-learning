- Redux をめぐる状態管理の歴史
    - Redux 以前の模索の時代
        - コンポーネントには自身が状態を持たないステートレスなコンポーネントと、自身の状態を持つステートフルなコンポーネントがある
        - コンポーネント固有の状態は state で扱ってきた けど、実際のアプリケーション開発では個々のコンポーネントにとどまらず、コンポーネントをまたいで 保持させたい状態が存在することがしばしばある
        - ユーザーがログイン中かどうかやそのアカウント情報
        - 状態はもっぱら個々のコンポーネントの中に閉じ込められてたので。React ではそういうアプリケーションでグローバルに持たせたい状態をどうやって管理するか
        -  React におけるグローバルな状態管 理を語る上で避けて通れない超重要な存在がひとつある。それが Redux ね。React の状態管理の歴史は Redux 以前、Redux 全盛期、ポスト Redux に分けられるといっても過言じゃない
        - 今は Redux を使わなくてもアプリケーションの状態管理は可能だし、それらは往々にして Redux より シンプルで理解しやすくなってる。ただ React + Redux の組み合わせがデファクトスタンダードになって た期間がかなり長く、既存のプロジェクトでは Redux がわからないとそのコードを読み解けないことが 往々にしてある
    - そして Redux が登場した
- Redux の使い方
    - Redux は公式 ドキュメントで 3 つの原則を掲げてる
        - Single source of truth (信頼できる唯一の情報源)
            - Redux ではアプリケーションの状態がただひとつの store オブジェクトによるツリー構造で表現される
            - Redux では複数の状態をシングルツリーの store に格納してるわけ。そうやって一元管理するこ とで、たとえばこれまでのアプローチでは難しかった undo / redo といった機能も簡単に実装できるようになる
        - State is read-only (状態は読み取り専用)
            - store の状態は読み込み専用で、直接書き換 えることができないということ
            - Redux で store の状態を変更するための唯一の方法は、どんなイベントが起こったかを表現する action を発行すること。変更手段を action だけに集約し、厳密にひとつずつ処理するようにすることで、書き 換えの競合や予期せぬ書き換えを防ぐことができる
        - Changes are made with pure functions (変更は純粋関数によって行われる)
            - Reduxではstoreは状態を格納するひとつのステートツリーと、それを更新するための Reducer という純粋関数で表現される装置から構成されてる
            - reducer では状態を内部に抱えず、ただの入出力値として扱う。それによって action が同じであ れば、入力した状態と出力された状態の差分も常に同一であることが保証されるわけ。学問的には入力 条件と現在の状態によって次の状態が決まる
    - Reduxの構造とデータフロー
        - https://gyazo.com/ed00a7231c968009e6bcf227a0e9849d
        - View から発行された Action は Dispatcher によって Reducer に渡される。そして Reducer はその Action と現在の State を受け取って、新しい State を生成する
        - Redux では dispatcher は store の構造や状態については一切関知せず、その名のとおり役割が action を reducer に送りつける(= dispatch)ことだけに限定される。そして状態を更新する reducer は純粋関数で あり、action が同じなら状態の差分も同じことが保証される
    - Redux をアプリケーションに組み込む
        - yarn add redux react-redux
