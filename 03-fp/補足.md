- 関数型プログラミングの推奨
    - 関数型プログラミングの『関数』は、数学的な意味合いが強い（例：y =f(x) + w）
    - 同じ入力に対して同じ作用と同じ出力が保証されていることを参照透過性という
    - 関数型プログラミングとは、参照透過的な関数を組み合わせることで解決するべき問題に対処していく宣言型のプログラミングのスタイル
    - プログラミングのパラダイムはまず大きく『命令型プログラミング（Imperative Programming）』と『宣言型プログラミング（DeclarativeProgramming）』の２つに大別される
    - 命令型
        - 最終的な出力を得るために状態を変化させる連続した命令文によって記述されるプログラミングスタイル
        - 命令型に分類される代表的なパラダイムが『手続き型プログラミング（Procedural Programming）』
    - 宣言方
        - 宣言型プログラミングでは出力を得る方法ではなく、出力の性質・あるべき状態を文字通り宣言することでプログラムを構成する
        - SQL がもっとも有名な宣言型プログラミング言語にあたる
    - 2つの違いの例、01-advantages/procedural-vs-functional.jsを参照

- コレクションの反復処理
    - 配列の反復処理。02-collection/array-iterate.jsを参照
        - map() …… 対象の配列の要素ひとつひとつを任意に加工した新しい配列を返す
        - filter() …… 与えた条件に適合する要素だけを抽出した新しい配列を返す
        - find() …… 与えた条件に適合した最初の要素を返す。見つからなかった場合は undefind を返す
        - findIndex() …… 与えた条件に適合した最初の要素のインデックスを返す。見つからなかった場合は -1を返す
        - every() ……「与えた条件をすべての要素が満たすか」を真偽値で返す
        - some() ……「与えた条件を満たす要素がひとつでもあるか」を真偽値で返す
    - 難易度高の反復処理。02-collection/array-iterate2.jsを参照
        - sort()は破壊的メソッド。02-collection/destructive.js参照
        - 配列に要素を追加し戻り値として新しい配列の長さを返すpush()や unshift()、配列から要素を取り除いてその値を返す pop()や shift()は破壊的メソッドで、返す値が更新した配列じゃないので関数型プログラミングの文脈では出番がない
        - 破壊的メソッドを、元の値を破壊せずに使える裏技。02-collection/non-destructive.jsを参照
    - 配列の反復処理には値を返さない構文。
        - Array.prototype.forEach() メソッド/for...of 文 （02-collection/array-iterate-for.js）
            - 本来ならどちらも使わない方が良い。
            - ほとんどの処理は map() や find() といった最初に挙げた値を返すメソッドでの組み合わせで十分なはずなので、どうしても他の方法が見つからなかった場のみ forEach()を例外的に使う。
    
    - オブジェクトの反復処理
        - 一旦配列を形成する方法がAirbnbのスタイルガイドでは推奨されている（02-collection/object-iterate.jsを参照）

- 改めて関数型プログラミングとは
    - 関数型プログラミングのパラダイム
        - 名前を持たないその場限りの関数（無名関数）を定義できる
        - 変数やデータ構造の値として関数を設定できる
        - 関数に引数として関数を渡したり、その戻り値に関数を設定できる（高階関数）
        - 関数に特定の引数を固定した新しい関数を作ることができる（部分適用）
        - 複数の高階関数を合成してひとつの関数にできる（関数合成）
    - 高階関数
        - 引数に関数を取ったり、戻り値として関数を返したりする（03-first-class/greeter.js参照）
    - カリー化と関数の部分適用
        - カリー化。複数の引数を取る関数を、より少ない引数を取る関数に分割して入れ子にする。（ 03-first-class/curried.jsを参照）
        - カリーかの部分適用（06-first-class/partially.jsを参照）
    - クロージャ
        - 関数を関数で閉じて包む。（03-first-class/closure-counter.js）
        - 関数と『その関数が作られた環境』の 2 つが一体となった特殊なオブジェクトのことを指す

- 非同期処理と例外処理
    - Promise で非同期処理を扱う
        - ES2015 から導入された JavaScript の標準組み込みオブジェクトで、非同期処理の最終的な 処理結果の値を文字通り『約束』する。
        - Promiseの中身（04-async/create-promise.jsを参照）
    - async と await
        - 04-async/get-user-then.jsを参照
            - node-fetchはモダンブラウザに実装されてるネットワークリクエスト操作のための Fetch API を、 ほぼ同じインターフェースで Node.js から使えるようにしたライブラリ
        - async と awaitの例。04-async/get-user-await.jsを参照
            - async キーワードを付与するとその関数は非同期関数となって、返される値が暗黙の内 に Promise.resolve()によってラップされたもの相当になる
            - await を使えば、.then().then().then()... なんて面倒なことを書かなくても、複数の非同期 処理を書いたまま順番に実行してくれる

- JavaScript の例外処理
    - try-catch-finally の構文で書く。04-async/try-catch.jsを参照
    

