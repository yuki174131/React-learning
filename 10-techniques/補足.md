- ロジックを分離、再利用する技術
    - React におけるロジック分離技術の歴史
        - 状態を扱う Hooks は State Hook、副作用を扱う Hooks は Effect Hook とカテゴライズされる
        - Hooks とは API インターフェースのことでもあるので、アプ リケーション開発者が自分で作れるし、最近はサードパーティーのライブラリも Hooks インターフェース による API を提供するようになってる
    - Custom Hook でロジックを再利用しやすくする
        - stateやeffectのみでは、まだHooksを関数コンポーネントに状態や副作用といったロジックを追加するためにしか使ってなくて、それらを分離して再利用できるようにはしてない
        - React では State Hook や Effect Hook を使ったロジックをひとまとめにして独立させ、それをコンポー ネントから必要に応じてインポートして利用するようにできる。それを Custom Hook という。
        - たとえば サンプルのカウントダウンタイマーのロジックを Custom Hook にして、それをインポートして使う
         - 02-custom-hook/src/components/Timer.tsx
         - 02-custom-hook/src/hooks/useTimer.tsx
    - フォームをハンドリングする
        - 素の React でフォームを扱うには
            - フォームを扱う際に気をつけるべき点
                - コンポーネントからイベントを扱う際、 React が提供する Synthetic Event が適用される
                - フォームの値をコンポーネントの state として持ち、値の反映には state のリフトアップを使う
            - 組み込みコンポーネントの onClick や onChange、onSubmit 属性にコールバック関数を渡すとその引数でイベントが受け取れる。
            - それがブラウザネイティブの各種 Event オブジェクトではなく、React 独自の SyntheticEvent オブジェクトになってる
             - <form onSubmit={(ev) => { ev.preventDefault(); console.log(ev); }> 
                <button type="submit">Submit</button>
                </form>
            - フォーム送信時にダンプされる ev が React では SyntheticEvent という独自のオブジェクトになっている
            - フォームコンポーネントの実装例
                - 03-form/raw-form/src/components/RegistrationForm.tsxを参照
                - その値を state で管理されるフォーム要素のことを『制御されたコンポーネント(Controlled Components)』という。React ではフォームの実装はこの制御されたコンポーネン トを使うことが推奨されてる
                - ref というリアル DOM を参照する属性を用いて仮想 DOM を経由せず直接フォーム要素の値にアクセスできる。この手法が用いられているフォーム要素を『非制御コンポーネント(Uncontrolled Components)』という。ユースケースとしてはたとえば、フォーカスが当たったりテキストが選択され たときに何らかのアクションを実行したい場合
                - onClick イベントはちょっと特殊で、親要素にも onClick イベントが仕掛けてあると子要素の onClickイベントが発火したとき連動して親のほうも発火してしまう。
                - ネストしてると子孫から親に向かってすべてのイベントが発火してしまう。イベント発火が下から泡のように浮き上がってくるので、これをイベントの『Bubbling(バブリング)』と呼ぶ。
                - この bubbling を防ぐために、イベントには stopPropagation メソッドが用意されてる
            - フォームヘルパーはどれ使うべきか
                - React Hook Form
                - バリデーションライブラリはYupがおすすめ
            - React Hook Form を使う
                - yarn add react-hook-form
                - 03-form/hook-form/src/components/RegistrationForm.tsxを参照
                - useFormの主なオプション（デフォルト値には『*』）
                    - mode : onChange | onBlur | onSubmit* | onTouched | all ...... どのタイミングでバリデーションがトリガーされるか。
                    - reValidateMode : onChange* | onBlur | onSubmit...... エラーのある入力が再度バリデーションされるタイミング。
                    - defaultValues : { elementName: elementValue }...... 各フォーム要素のデフォルト値。この値を適切に設定していれば型推論が効くため型引数は省略可能。
                    - resolver...... 外部バリデーションライブラリを利用するためのカスタムリゾルバを設定する。
                    - shouldUnregister : true | false*...... 登録していたフォーム要素がアンマウントされると同時に React Hook Form もその入力値を破棄する。
                    - shouldFocusError : true* | false...... フォームが送信されエラーが含まれている場合に、エラーのある最初のフィールドにフォーカスする。
                - useFormの戻り値のオプション
                    - register...... フォーム要素を React Hook Form の管理下に置くよう登録するための関数。ref 、 name 、 onChange 、 onBlur の属性に対応したプロパティを含むオブジェクトが返される。
                    - formState...... フォームの各種状態を検知するためのオブジェクト。以下のプロパティが含まれる。
                    - isDarty...... フォーム内容が初期値から変更されているか
                    - dartyFields...... 初期値から変更されたフォーム要素
                    - touchedFields...... 一度でもユーザーによる操作のあったフォーム要素 
                    - isSubmitted...... フォームが送信されたかどうか 
                    - isSubmitSuccessful...... フォームの送信が成功したかどうか
                    - isSubmitting...... フォームが送信中かどうか
                    - submitCount...... フォームが送信された回数
                    - isValid...... フォームの内容にバリデーションエラーがないかどうか 
                    - isValidating...... フォームの内容をバリデーション中かどうか
                    - errors...... 各フォーム要素に対応したバリデーションエラーの内容が格納されているオブジェクト 
                    - watch...... 各フォーム要素の値を監視し、変更が即時反映された値を返す関数。コンポーネントの再レンダリングを引き起こすため、パフォーマンス悪化につながらないよう使用には注意が必要。
                    - handleSubmit...... 引数として関数を受け取り、フォームが送信されたときにフォームデータをその関数に渡して実行する高 階関数。
                    - reset...... フォームの状態をすべてリセットする関数。引数のオプション指定で部分的かつ条件をカスタマイズした リセットが可能。
                    - setError...... バリデーションの結果に関わらず、手動で任意のエラーを設定できる関数。
                    - clearErrors...... エラーをクリアする関数。引数で指定した要素のエラーのみクリアすることもできる。
                    - くわしくは公式サイトの API リファレンスを参照
                - フォームの構造は useForm 実行時に型引数として与えるか、それがない場合は引数オプションの defaultValues の設定値から型推論される
            - Yup でスキーマバリデーション
                - React Hook Form のバリデーションを Yup によって行う場合、Yup 本体に加えてカスタムリゾルバのパッケージをインストールする必要がある
                    - yarn add yup @hookform/resolvers
                - 03-form/hook-form/src/schamas/registrationForm.ts を参照
                - React Hook Form にフォームのバリデーションをさせるためのコード
                    - 03-form/hook-form/src/components/ValidRegistrationForm.tsxを参照
                    - resolverオプション
                    - useForm の引数オプションの mode や reValidateMode、 shouldFocusError で調整できる
        - コンポーネントのレンダリングを最適化する
            - コンポーネントのライフサイクル
                - コンポーネントにはマウントして初期化され、次にレンダリングされた後、何らかのきっかけで再レンダリングされ、最後にアンマウントされるまでのライフサイクルがある
                - それらの各タイミングに介入して任意の処理を行うために、ライフサイクルメソッドというものが用意されてる
                - 再レンダリングが発生するの はどんなときか
                    - props が更新されたとき
                    - state が更新されたとき 
                    - 親コンポーネントが再レンダリングされたとき 
                    - 参照している context が更新されたとき
                - 関数コンポーネントのライフサイクル図
                    - https://gyazo.com/f2c40c7545415c9debe603dabc32995b
                    - Mounting フェーズはコンポーネントが初期化され、実行さ れた出力が仮想 DOM にマウントされるまでのフェーズ
                        - 関数コンポーネントが頭から実行され、 state が定義されていればその領域が確保される
                        - 実行の結果、React Elements が return される
                        - Effect Hook で副作用処理を設定していれば、その後にそれが実行される
                        - useEffect に記述した副作用処理が中途半端に短時間で終わってしまう場合、UI をちゃんと考 慮してないと画面がちらついてユーザーに違和感を与えてしまうことがある。なお Effect Hook にはもう ひとつ useLayoutEffect という API が用意されてる 。ブラウザへの出力プロセスに対して同期的に実行され、副作用処理が終わるまでブラウザへの反映はブロックされる
                        - 安易に useLayoutEffect を使うのは NG。Web パフォーマンスの計測指標に『FCP(First Contentful Paint)39』という視覚コンテンツの初期表示までの時間を表すものがあるけど、useEffect の仕様はこの FCP を最小化するためのもの
                        - 副作用の処理がコンポーネントの表示をブロックしない、というのがレスポンス性を高めてアプリケ ーション全体での UX の向上につながる。まず useEffect を使ってユーザーに違和感を与えない UI を構築して、他に方法がないときだけ例外的に useLayoutEffect を用いるようにするべき
                    - Updating フェーズは先ほどの4つのケースを React が検知してコンポーネントが再実行される。その出力結果が前回のものと比較され、差分があればその部分のブラウザ表示を差し替える
                        - 『deps』は依存配列に格納した変数のことで、Hooks 関数 にこれが渡されその値の更新があった場合となかった場合で挙動が変わる。
                        - deps が更新された場合、もしくは依存配列が設定されてなかった場合、return 後に副作用処理が実行される
                        - Effect Hook に クリーンアップ関数が設定されていれば、副作用処理の前にそれが実行される
                    - Unmounting フェーズ。コンポーネントが仮想 DOM から削除され、ブラウザ表示からも消える
                        - Effect Hook に登録していたクリーンアップ関数だけが実行される
                - メモ化で計算リソースを節約する
                    - useMemoとuseCallback という Hooks API がある。不要な再レンダリングを防ぐために提供されてるものなの。これには『メモ化 (Memoization)』という概念をまず理解しておく必要がある
                    - 『メモ化 (Memoization)』という概念
                        - これも関数型プログラミングの文脈でよく用いられる手法。関数内における任意のサブルーチンを呼び出した結果を後で再利用するために保持しておき、その関数が呼び出されるたびに再計算されることを防ぐ、プログラム高速化の手法
                        - 04-optimize/memoize/src/utils/prime.ts, 04-optimize/memoize/src/hooks/useTimer.pre.ts を参照
                - メモ化で不要な再レンダリングを防ぐ
                    - リセットボタンが押されたときにインターバル実行もやり直す必要がある
                    - こういう場合は useRef を使う。非制御コンポーネントで直接 DOM を参照するのに ref という属性を使う
                    - useRef で定義した値は .current という書き換え可能なプロパティを持つ。それを組み込みコンポーネ ントの ref に入れておくと、React がリアル DOM を出力した際にその対応する要素を参照する値が .current の中に設定されるの
                    - useRef は ref 属性だけじゃなく、汎用的な値にも使うことができる。だから好きに自分で .currentプロパティに値を入れたり更新して、それをコンポーネントに任意の場所で参照すればいい
                    - 新しい reset では、前のインターバル ID があればそれでクリアして、カウントを初期値に 設定して、新規にインターバルプロセスを始める
                    - 04-optimize/memoize/src/hooks/useTimer.tsを参照
                - 優先度の低いレンダリングを遅延させる
                    - フォームの入力値をリアルタイムで何らかの重い処理にリンクして ると、入力の反応が鈍くなったり画面の更新がガタガタすることがある
                    -  React 18 ではあらかじめ任意の state 更新における緊急性をマークしておくことで、緊急性の低 い更新を必要に応じて遅らせることができる機能が導入された
                    - 04-optimize/deferred/src/components/Profile.tsxを参照
                        - フォームテキストを更新するためのレンダリングが優先されて、プロフィール情報の更新 のレンダリングが遅延されてる


