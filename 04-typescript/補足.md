- TypeScriptの基本的な型
    - 型アノテーションと型推論
        - TypeScriptのローカルマシンでの実行環境は ts-node が代表的
        - TypeScript では value: Type というフォーマットで宣言時の変数に型 の注釈がつけられる。これを『型アノテーション(Type Annotation)』と呼ぶ。
        - 型アノテーションに よって静的に型付けされた情報はコンパイル時のチェックに用いられ、書かれたコード中に型の不整合が あるとコンパイルエラーになる
        - コンパイラがその文脈からその型を推測できる場合は、型アノ テーションを省略しても自動的に補完して解釈してくれる（型推論）
    - JavaScriptと共通のデータ型
        - プリミティブ型は JavaScript と共通した次の 7 種類
            - Boolean 型 ...... true および false の 2 つの真偽値を扱うデータ型。型名は boolean ・Number 型 ...... 数値を扱うためのデータ型。型名は number
            - BigInt 型 ...... number 型では表現できない大きな数値( 253 以上)を扱う型。型名は bigint 
            - String 型 ...... 文字列を扱うためのデータ型。型名は string
            - Symbol 型 ......「シンボル値」という固有の識別子を表現する値の型。型名は symbol 
            - Null 型 ...... 何のデータも含まれない状態を明示的に表す値。型名は null 
            - Undefined 型 ......「未定義」であることを表す値。型名は undefined
        - 配列の型
            - const numArr: number[] = [1, 2, 3];
                - 型名の後ろに [] をつける
            - const strArr: Array<string> = ['one', 'two', 'three'];
                - 上記推奨される
            - const red: { rgb: string, opacity: number } = { rgb: 'ff0000', opacity: 1 };
                - オブジェクトの型を定義する際は、プロパティのキー名と値の型を明記する形でこのように型アノテーションを使う
            - TypeScript ではオブジェクトの型に名前をつけることができるようになってるいて、『インターフェース(Interface)』と呼ばれる
                - 02-basic-types/interface-sample.tsを参照
                - プロパティをもっと柔軟に定義する記法（インデックス シグネチャ(Index Signature)）。02-basic-types/index-signature.tsを参照
                    - インデックスシグネチャを使うとすべてのプロパティがその定義に従う 必要がある
        - Enum 型とリテラル型
            - Enum
                >enum Pet{
                > Cat='cat',
                > Dog='dog',
                > Rabbit='rabbit',
                >}
            - リテラル型
                - ユニオン型と使い合わせる
                - > let Mary: 'Cat' | 'Dog' | 'Rabbit' = 'Cat';
            - リテラル型は文字列 Enum と比べてもシンプルに記述できて扱いやすく、JavaScript へのコンパイル後 のコードもより短くなるというメリットあり
            - リテラル型は文字列だけじゃなく、数値もサポートされている
        - タプル型
            - 個々の要素の型に加えて、その順番や数に制約を設けられる特殊な配列の型
                - const charAttrs: [number, string, boolean] = [1, 'patty', true];
            - よく使われてるものでは関数の引数
            - タプルの定義にもレストパラメータが使える
                - const spells: [number, ...string[]] = [7, 'heal', 'sizz', 'snooz'];
        - any、unknown、never
            - any で定義された変数は、その名のとおりいかなる型の値でも受けつけるようになる
                - データの型が不明なまま処理を書いていかなければいけない場面、たとえば JSON ファイルをパースしてそのままオブジェクトとして使う場合とか、事前に一律の型を当てはめるのが難しかったりする場面に使用
            - unknown は any の型安全版で、 任意の型の値を代入できる点は同じなんだけど、それ自体は何のプロパティもプロトタイプメソッドも 持たない型
                - 02-basic-types/json-parse-unknown.tsを参照
            - never。『何者も代入できない型』。
                - 02-basic-types/never-case.tsを参照
    - 関数とクラスの方
        - 関数の型定義
            - TypeScript ではコンパイラオプションに noImplicitAnyが指定されてないと、引数の型定義がなくて も暗黙の内に any があてがわれてコンパイルが通ってしまうので、設定ファイルの tsconfig.json を置いてそのオプションを有効にしておく
            - TypeScript では戻り値の型は型推論が有効な場合には省略もできるが、引数の型は必ず指定する必要がある
                -  03-function-class/function-type.tsを参照
            - 引数と戻り値をまとめて定義する方法もある。関数を『呼び出し可能オブジェクト(Call Signature)』として定義するもの。
                - 03-function-class/callable.tsを参照
            - 型引数（ジェネリクス）
                - 3-function-class/type-params.tsを参照
        - TypeScriptでのクラスの扱い
            - 03-function-class/rectangle.tsを参照
            - 『アクセス修飾子(Acdess Modifier)』というのもあって、これも宣 言時につけることでそのメンバーのアクセシビリティをコントロールできる
                - public ...... 自クラス、子クラス、インスタンスすべてからアクセス可能。アクセス修飾子を省略するとすべてのメンバーはこれになる
                - protected...... 自クラスおよび子クラスからアクセス可能。インスタンスからはアクセス不可
                - private...... 自クラスからのみアクセス可能。子クラスおよびインスタンスからはアクセス不可
                - プライベートメンバーの指定って JavaScript では頭に # をつけて 宣言していた
                - コンパイル時の振る舞いは target オプションで指定されるコンパイル後の JavaScript バージョンによって次のように変わるの
                    - 1. ES5 以前 ...... コンパイルエラーになる
                    - 2. ES2015 〜 ES2021 ...... 互換コードにコンパイルされる 
                    - 3. ES2022 ...... そのまま残される
                - 現在では継承より合成が推奨されている
                    - 継承例。03-function-class/inheritance.tsを参照
                    - 合成例。 03-function-class/composition.tsを参照
                    - 依存がないゆえに Rectangle クラスの内部の変更に Square クラスが影響されることは ない。個々のモジュールの独立性が高く、より保守性に優れたコード
            - クラスの２つの顔
                - クラスの型を抽象化して定義する方法が、TypeScript には 2 つある。abstract修飾子を用いて抽象クラスを定義するもの、もう一つはインターフェース
                - 抽象クラスはその定義に実装を含むことができてしまうので、インターフェースが推奨される。
                    - 03-function-class/implements.tsを参照
                    - 03-function-class/points.tsを参照
        - 型の名前と型合成
            - 型エイリアスvsインターフェース
                - 04-type-composition/type-alias.tsを参照
                - インターフェース文は型の宣言なので、その型にはオリジナルの名前が与えられる。いっぽう型エイリアスの構文はすでに無名で作られてしまった型に参照のための別名を与えているものなので、その型にはオリジナルの名前がないまま。
                - これは関数の宣言文と関数式の関係に似てる。セミコロンの有無も同様で、関数宣言とインターフェース構 文はブロック {} で終わる文なのでセミコロンが不要。
                - インターフェースは拡張に対してオープンな性質がある
                    - Declaration Merging(宣言のマージ)。04-type-composition/openly-interface.tsを参照
                - インターフェースと型エイリアス、オブジェクトの型を定義するのにはどっちを使ったほうが良いか？
                - コミュニティでずっと論争になってる問題だが、、インターフェース派のほうが優勢。
                    - 拡張性とエラーメッセージに必ず名前が記載されることから 基本的にはインターフェースを薦めてる
                - いつもは インターフェースを使うけど拡張性より厳密性が要求されるコンポーネントにまつわる各種定義だけは型エイリアスを用いるという人が多い
        - ユニオン型とインターセクション型
            - TypeScript では既存の型を組み合わせて、より複雑な型を表現できる
            - ユニオン型
                -  let id: number | string = 16384
                - numberもstringも許容される
                - オブジェクトもユニオン型に適用できる。04-type-composition/union-types.ts参照
            - インターセクション型
                - 『A かつ B』と複数の型をひとつに結合させる
                - 04-type-composition/intersection-types.tsを参照
                - 04-type-composition/type-extension.tsを参照
        - 型のNull安全性を保証する
            - TypeScript で厳密に null や undefined を他の型から区別するためには、コンパイラオプション strictNullChecksを設定する必要がある
             -  + "strictNullChecks": true,
    - さらに高度な型表現
        - 型表現に使われる演算子
            - typeof。
                - これは通常の式では渡された値の型の名前を示す文字列を返すんだけど、型の コンテキストで用いると変数から型を抽出してくれる
                - 05-advanced/typeof.tsを参照
            - in 演算子
                - 列挙された型の中から各要素の型の値を抜き出してマップ型 (Mapped Type) というもの
                - 05-advanced/in.tsを参照
            - keyof
                - 通常コンテキストにはなく、型コンテキストのみで用いられる演算子。オブジェクトの型からキーを抜き出してくる
                - 05-advanced/keyof.tsを参照
            - valueofはないので、インデックスアクセス演算子を使う
                - 05-advanced/index-access.tsを参照
                - 汎用的なユーティリティ型を作る例。05-advanced/valueof.tsを参照
        - 条件付き型とテンプレートリテラル型
            - クラスやインターフェースの拡張に使われる extends キーワードは 型引数の表現にも適用できる
                -  05-advanced/extends.tsを参照
            - 条件付き型
                - オブジェクトの型から任意のプロパティの型を抽出したりするとき
                    - 05-advanced/conditional.ts参照
                - 関数の型から任意の引数の型を抽出するような使いみち<infer>
                    - 05-advanced/conditional-infer.tsを参照
            - テンプレートリテラル型
                - テンプレートリテラルによる文字列を型として扱うことができる
                    -  05-advanced/template-literal.tsを参照
                - クエリやパスにも型をつけられる
                    - 05-advanced/template-sql.tsを参照
                    - 05-advanced/template-picktable.tsを参照
            - 組み込みユーティリティ型
                - よく使われているもの
                    - Partial<T> ...... T のプロパティをすべて省略可能にする
                    - Required<T> ...... T のプロパティをすべて必須にする
                    - Readonly<T> ...... T のプロパティをすべて読み取り専用にする
                    - Pick<T, K> ...... T から K が指定するキーのプロパティだけを抽出する
                    - Omit<T, K> ...... T から K が指定するキーのプロパティを省く
                        - 05-advanced/pick-omit.tsを参照
                    - Extract<T, U> ...... T から U の要素だけを抽出する
                    - Exclude<T, U> ...... T から U の要素を省く
                        - 05-advanced/extract-exclude.tsを参照
                    - NonNullable<T> ...... T から null と undefined を省く
                        -  05-advanced/non-nullable.tsを参照
            - 関数のオーバーロード
                - 同じメソッド名だけど、引数の型や個数による与え方で異なるメソッドが実行される
                - 05-advanced/function-overload.tsを参照
                - 関数を呼び出し可能オブジェクトとして型を多重定義する  
                    - 05-advanced/callable-overload.tsを参照
    - 型アサーションと型ガード
        - as による型アサーション
            - 型がわからない値をどうやって TypeScript でうまく扱うか。
            - いちばん手っ取り早い解決法は『型アサーション(Type Assertion)』を行う
            - 06-type-guard/type-assertion.tsを参照
            - だから型アサーションは本当に最後の手段
        - 型ガードでスマートに型安全を保証する
            - 型をインテリジェントに絞り込んであげる
                - 06-type-guard/typeof-guard.tsを参照
                - typeof によって変数 foo が文字列として型の絞り込みが行われたブロック内では、String のプロトタイプメソッドである split() が使えている。
                - このように、あるスコープ内での型を保証するチェックを行う式のことを型ガード(Type Guard)という
                - プリミティブ型の場合以外で、クラスのインスタンスなら instanceof が使える
                    - 06-type-guard/instanceof-guard.tsを参照
                - ユーザー定義の型ガード
                    - 自前で型を絞り込むしくみを作ってあげる
                    - 06-type-guard/user-defined.tsを参照
    - モジュールと型定義
        - TypeScript のインポート/エクスポート
            - TypeScript における import と export の書き方は JavaScript のところで説明したのとほぼ同じ。
            - 異なるのがインポートに指定するパスでの拡張子の扱い。TypeScript ではインポートの際に読み込む ァイルの拡張子を省略できる
            - import bar from './foobar';の場合、 TypeScript は次の順にモジュールを探索していく
                - 1. src/foobar.ts 
                - 2. src/foobar.tsx 
                - 3. src/foobar.d.ts
                - 4. src/foobar/package.json の types または typings プロパティで設定されている型定義ファイル 
                - 5. src/foobar/index.ts
                - 6. src/foobar/index.tsx
                - 7. src/foobar/index.d.ts
            - TypeScript ではインターフェースや型エイリアスといったものも import と export の対象になる
                - 07-module/exports.tsを参照
            - TypeScript では、同じ名前空間の中に『変数 宣言空間(Variable Declaration Space)』と『型宣言空間(Type Declaration Space)』という 2 つの宣言空間が存在していて、名前の管理が別々になってる。そのため変数や関数と型で同一の名前を持つことができる
                - 07-module/currency-export.tsを参照
                - 07-module/currency-import.tsを参照
            - 型のみのインポート(Type-Only Import)』と『型のみのエクスポート(Type-Only Export)
                - 07-module/resident.tsを参照
                - 07-module/type-import.tsを参照
        - JavaScript モジュールを TypeScript から読み込む
            - npm のリポジトリで提供されている多くのパッケージは、 JavaScript 形式 になってる
            - TypeScript から読み込めるように JavaScript のモジュールを作る
                - 07-module/dts/sailormoon-transform.tsをモジュール化する
                - 07-module/dts/tsconfig.jsonを参照
                    - "declaration": trueが重要
                - 04-typescript/07-module/dtsディレクトリで tsc を実行すると、sailormoon-transform.d.ts が作成される。
                - 07-module/dts/main.tsを作成し、  ts-node main.ts にてTypeScriptで実行できる
        - モジュールの型はどのように解決されるか
            - import { uniq } from 'lodash' のようにインポート元のモジュールを相対パスで記述しないのを『非相対インポート(Non-Relative Import)』と呼ぶ
            - 想定される3ケース
                - 1. 公式が型定義ファイルを提供してくれていて、そのパッケージに内包されている
                - 2. 公式が型定義ファイルを提供していないが、第三者により Definitely Typed から提供されている
                - 3. 公式が型定義ファイルを提供しておらず、自作や拾ってきた型定義ファイルを適用する
            - 目当ての型定義ファイルを探すなら TypeScript 公式サイトの『Type Search232』で検索すると良い。また、命名規則として Definitely Typed で提供されているパッケージは頭に「@types/」がつくので、npm のサイトからでも@types/react のように「@types/」をつければたいてい見つかる。もしくは yarn info @types/react のように Yarn コマンドで調べることもできる。
            - Lodash は型定義ファイルを内包してなくて、Definitely Typed から提供されている。だから TypeScript から Lodash を使いたい場合は @types/lodash パッケージを別途インストールする必要がある
            - TypeScript 公式サポートなら『TS』、Definitely Typed で型が提供されているなら『DT』アイコンがついてる
            - Definitely Typed に型定義が登録されてるならその型パッケー ジをインストールするようファイルに追記してくれるtypesyncというコマンドパッケージがある
            - 公式でも Definitely Typed でも型ファイルが提供されてない 3 のケース。それでも TypeScript から使いたければ、自分で型定義を作るか、誰かが野良で公開している型定義を導入するしかない。こ こでは例として super-awesome という型定義を持たないパッケージに自作の型を当てはめる場合を考え よう。まず super-awesome.d.ts という名前で次のような内容の型定義ファイルを作る
    - TypeScript の環境設定
        - コンパイラオプション strict
            - tsc --help を実行すると、オプションの設定が全て出てくる
            - Viteのデフォルト設定。08-config/tsconfig.jsonを参照
            - strict というオプションが true になっていると、次のオプションたちがまとめて有効にされる
                - alwaysStrict...... すべてのソースファイルの先頭に 'use strict' が記述されているものとみなし、 ECMAScriptのstrictモードでパースする 
                - noImplicitAny...... 暗黙的に any が指定されている式や宣言があればエラーにする 
                - noImplicitThis...... this が暗黙的に any を表現していればエラーにする 
                - strictNullChecks...... 他のすべての型から null および undefined を代入不可にする 
                - strictBindCallApply...... bind()、 call()、 apply() メソッド使用時に、その関数に渡される引数の型チェックを行う
                - strictFunctionTypes...... 関数の引数の型チェックが「共変的( Covariant )」ではなく、「反変的( Contravariant )」に行われるようにする
                - strictPropertyInitialization...... クラスにおいて宣言だけで初期化されないプロパティがあるとエラーになる(※ strictNullChecks も併せて有効にしておく必要あり)
                - useUnknownInCatchVariables...... catch 文で捕捉した例外を unknown として扱う
            - strict オプションを有効にすることは、TypeScript の公式 でも推奨されてる
            - 気をつけないといけないのは、TypeScript のバージョンアップに伴ってこれに含まれるオプショ ンがいつのまにか増えてしまう
            - バージョンアップの際はリリース ノートをよく確認
        - tsconfig.json の設定項目
            - 公式ドキュメントを参照
        - 複数の tsconfig.json を連携させる
            - tsconfig.json は設定を複数のファイルに分割してそれらを連携させることができる。それがトップ階層で指定できる残り 2 つのプロパティ項目
                - extends...... 他の設定ファイルを継承する。双方のファイルに同じ項目の設定があれば、継承先の値で上書きされる
                - references...... 他の TypeScript プロジェクトを参照する
            - extends オプションはシンプルに他のファイルの設定を継承するだけね。たとえば構文解析の対象とな るディレクトリを限定したいといった場合、元の tsconfig.json を継承して include や exclude の設定 値を上書きし、構文解析ツールにはそちらを読み込ませるといった使いみち
            - referencesオプションはロントエンドとバックエンドのプロジェクトを同じリポジトリで管理したいけど、共通 API が置いてある share/ 配下以外 は相互に参照できないようにしたいといったニーズに応える
            - 08-config/tsconfig.node.jsonを参照
                - Vite の設定 ファイルを TypeScript で書いて、プロジェクトコードから参照できるようにするための設定
                