- コンポーネントのメンタルモデル
    - React はコンポーネントという独立した再利用可能なパーツを組み合わせることによってアプリケーシ ョンを作る、コンポーネントベース・アーキテクチャを採用している技術
    - React はメモリ上に ReactElement オブジェクトのツリーを持っており、それを HTMLElement による DOM ツリーに還元し、ブラウザに出力することでアプリケーションとして動作する
    - React Elements はコンポーネントを任意の props でコールするための実行リンクのようなもの
    -  React ではコンポーネントをプログラム の関数のようなものと考えるのが一番近い
    - propsを引数として受け取り、戻り値としてReact Elements を返す関数。返された React Elements がそのコンポーネントのレンダリング結果になる
        - レンダリングはコンポーネント単体においてはその実行結果の React Elements の出力のことを指す
    - コンポーネントのレンダリングに差分が発生するかどうかを知るためには、その props と state だけを 見ていればいい
        - これは仮想 DOM による再レンダリングがどのように行われるかを理解するのに役立つ。React の差分 検出処理エンジンは、仮想 DOM 内の React Elements すべてを監視していて、そのどれかの props または その保持している state の値に変更を検知すると、その新しい値でコンポーネント関数を再実行するよう になってる
- コンポーネントに Props を受け渡す
    - コンポーネントにとっての最大の関心事は props と state。
    - 関数型プログラミングによってアプリケーショ ンの UI を宣言的に記述するという React の思想を具現化するためには、副作用の原因となるコンポーネ ントの state を極力持たせないようにしたい
    - 純粋関数とは、引数が同じなら必ず同じ戻り値を返す関数のこと。ゆえに React にとって理想的なコンポーネントとは、props が同じなら必ずレンダリング結果が同じになるコンポーネント。コンポーネントにとって props がもっとも重要。
    - props とはコンポーネントにとっての関数に対する引数のようなもの。JSX におけるマウント時のタグの中では、そのタグの 属性値として記述される。そして JSX が生成する React Elements を通してコールされたコンポーネント側 には、それが { 属性名: 属性値 } の形式のオブジェクトとして渡される
    - 9-basics/02-props/src/App.tsx, 09-basics/02-props/src/components/CharacterList.tsxを参照
- コンポーネントに State を持たせる
    - コンポーネントで stateを作成するには useState() という API を使う
    - useState は引数として state 変数の初期値を取り、戻り値として state 変数とその state を更新するセッ ト関数をタプルにして返す。それらは一般的に、以下のように分割代入で受け取る
        - const [count, setCount] = useState(0);
    - useState に引数として渡した初期値によって state 変数の型が推論される
        - state 変数がたとえば通常は文字列だけど初期値に null を取るような値の場合とか、何らか の値の配列だけど初期値は空配列にしたい場合とかは次のように型引数を与える形でコールしないと、 型推論がうまく働かずセット関数で意図した値が設定できなくなるので注意。
        - const [id, setId] = useState<string | null>(null);
        - const [members, setMembers] = useState<Member[]>([]);
    - useState を使ったサンプルコード
        - src/components/Counter.tsxを参照
        - Hooks の呼び出しはその関数コンポーネントの論理階層のトップ レベルでないといけないということ。つまり条件文や繰り返し処理の中で呼びだすのはタブー。
- コンポーネントと副作用
    - 具体例として React の公式ドキュメントに挙がっているのは、ネットワークを介したデータの取得やそのサブスクリプション(随時反映)、ログの記録、リアル DOM の手動での書き換えといったもの。 副作用は英語では side-effect、または単に effect とも呼ばれる。
    - 副作用とはコンポーネントの state を変化させ、出力を変えてしまう処理のこと
    - 関数y=f(x) は本来xが同じなら出力値yも同じはずだけど、状態を抱える関数 であれば必ずしもそうとは限らない。たとえば f(1) は 2 を返していたのが任意の処理を実行することで、 それ以降は f(1) が 5 を返すようになる、これが副作用ということ
    - props が同じであってもその関数コンポーネントの state を変えさらに戻り値までも変えてしまうよう な処理を行うための副作用 API が React には用意されてる
    - useEffectの使い方
        -  const SampleComponent: FC = () => {
                const [data, setData] = useState(null); …
                useEffect(() => {
                    setData(...);
                    return () => clearSomething(); }, [someDeps]);

            };
        - useEffect は第 1 引数として、引数を持たない関数を受け取る。この関数の中身が 任意のタイミングで実行される
        - ここではその中でセット関数 setData を呼んでいる
        - その関数が最後にまた引数のない関数を返してる
        - useEffect へ第 1 引数として渡す関数がその戻り値として任意の関数を返すようにしておくと、そのコンポーネントがアンマウントされるときにその関数を実行してくれる
        - この関数をクリーンア ップ関数(Cleanup Function)と呼ぶ
        - クリーンアップ関数として具体的にどんなものを登録しておくかというと、たとえば外部の API から アクティブにデータをサブスクリプション(購読)する処理を実行していたら、コンポーネントのアンマウント時にはそれを解除する必要がある。そういった用途で使う
        - useEffect の第 2 引数には変数の配列が渡せる
        - この配列の中に格納された変数が ひとつでも前のレンダリング時と比較して差分があったときだけ、第 1 引数の関数が実行される
        - この第 2 引数のことを 依存配列(dependencies array)という
        - 第 2 引数は省略可能。ただし依存配列が渡されなかった場合、レンダリングがあるたびに毎回第 1 引 数の関数が実行されることになる。いっぽう空配列 [] を渡すと、初回のレンダリング時にのみ第 1 引数 の関数が実行される
        - 設定をまちがうと無限ループになったりする
        -  09-basics/04-effect/src/components/Timer.tsxを参照
        - https://overreacted.io/ja/a-complete-guide-to-useeffect/ を参照
- クラスでコンポーネントを表現する
    - React が今のように関数コンポーネントが主体にな ったのは、2019 年 2 月リリースの 16.8 で関数コンポーネントが状態や副作用を持てるようになってから
    - それまでは React.createClass() というメソッドを使って擬似的にクラスでコンポーネントを作ってた
    - カウントダウンタイマーをクラスコンポーネントで書き直した例
        - 09-basics/05-class/src/components/Timer.tsxを参照
